\section{Sorting}
\begin{frame}\frametitle{Sorting - Overview}
\begin{itemize}
\item Sorting: Organizing data based on its value
	\begin{itemize}
	\item Usually based on numeric value or alphabetical value
	\end{itemize}
\item Efficiency
	\begin{itemize}
	\item Speed: How many comparisons are made and how many swaps are required
	\item Space: How much memory is required
	\item More memory in usually traded for faster speed
	\end{itemize}
\item Divide and conquer: Method some algorithms use to sort smaller sections of data and merging them back together
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Sorting - Selection Sort}
\begin{itemize}
\item Selection sort: Continually swap the smallest/largest unsorted value with the first unsorted element
	\begin{itemize}
	\item Completes redundant swaps
	\end{itemize}
\item Efficiency
	\begin{itemize}
	\item Best case: $O(n^2)$
	\item Worst case: $O(n^2)$
	\item Average case: $O(n^2)$
	\item $n - 1$ swaps will always be performed
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Sorting - Code}
Basic selection sort code
\lstinputlisting[basicstyle=\tiny, firstline=6]{code/selection-sort.cpp}
\end{frame}

\begin{frame}\frametitle{Sorting - Code}
Output
\verbatiminput{code/selection-sort-output.txt}
\end{frame}

\begin{frame}\frametitle{Sorting - Bubble Sort}
\begin{itemize}
\item Bubble sort: Move the smallest/largest value to the front/end of the list
	\begin{itemize}
	\item Compare each item to its immediate successor
	\item The next smallest/largest value will be moved to its correct place each pass through
	\end{itemize}
\item Efficiency
	\begin{itemize}
	\item Best case: $O(n)$, $0$ swaps
	\item Worst case: $O(n^2)$, $\frac{n^2}{2}$ swaps
	\item Average case: $O(n^2)$, $(\frac{1}{2})(\frac{n^2}{2})$ swaps
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Sorting - Code}
Basic bubble sort code
\lstinputlisting[basicstyle=\tiny, firstline=6]{code/bubble-sort.cpp}
\end{frame}

\begin{frame}\frametitle{Sorting - Code}
Output
\verbatiminput{code/bubble-sort-output.txt}
\end{frame}

\begin{frame}\frametitle{Sorting - Insertion Sort}
\begin{itemize}
\item Insertion sort: Move each item to its proper place in reference to its predecessors
	\begin{itemize}
	\item Assumes the first item is sorted
	\end{itemize}
\item Efficiency
	\begin{itemize}
	\item Best case: $O(n^2)$
	\item Worst case: $O(n^2)$, $\frac{n^2}{2}$ swaps
	\item Average case: $O(n^2)$, $(\frac{1}{2})(\frac{n^2}{2})$ swaps
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Sorting - Code}
Basic insertion sort code
\lstinputlisting[basicstyle=\tiny, firstline=6]{code/insertion-sort.cpp}
\end{frame}

\begin{frame}\frametitle{Sorting - Code}
Output
\verbatiminput{code/insertion-sort-output.txt}
\end{frame}

\begin{frame}\frametitle{Sorting - Quick Sort}
\begin{itemize}
\item Quick sort: Divide and conquer sorting algorithm by partitioning around a pivot and recursively sorting each pivot
	\begin{itemize}
	\item Values less than the pivot go to one side, and values greater than the pivot go to the other side
	\item Base case: A partition has one element
	\end{itemize}
\item Efficiency
	\begin{itemize}
	\item Best case: $O(n\log n)$ (Each split generates equally-sized partitions)
	\item Worst case: $O(n^2)$ (Mostly sorted)
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Sorting - Code}
Basic quick sort code
\lstinputlisting[basicstyle=\tiny, firstline=6]{code/quick-sort.cpp}
\end{frame}

\begin{frame}\frametitle{Sorting - Code}
Output
\verbatiminput{code/quick-sort-output.txt}
\end{frame}

\begin{frame}\frametitle{Sorting - Merge Sort}
\begin{itemize}
\item Merge sort: Continually divide the dataset into smaller datasets and sorting and merging them back together
\item Efficiency
	\begin{itemize}
	\item Best case: $O(n \log n)$
	\item Worst case: $O(n \log n)$
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Sorting - Code}
Basic merge sort code
\lstinputlisting[basicstyle=\tiny, firstline=7]{code/merge-sort.cpp}
\end{frame}

\begin{frame}\frametitle{Sorting - Code}
Output
\verbatiminput{code/merge-sort-output.txt}
\end{frame}

\begin{frame}\frametitle{Radix Sort}
\begin{itemize}
\item Sorting elements in a dataset based on its value within a known range (Ex: Leading digit)
\item Efficiency
	\begin{itemize}
	\item $O(kn)$, where $k$ is the amount of times each data set is sorted
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Sorting - Code}
Basic radix sort code
\lstinputlisting[basicstyle=\tiny, firstline=6]{code/radix-sort.cpp}
\end{frame}

\begin{frame}\frametitle{Sorting - Code}
Output
\verbatiminput{code/radix-sort-output.txt}
\end{frame}

\begin{frame}\frametitle{Heap Sort}
\begin{itemize}
\item Heap sort: Get and remove the maximum value from a sorted heap, then heapify the updated heap
\item Efficency
	\begin{itemize}
	\item Heap construction: $O(n)$
	\item Heapify once: $O(\log n)$
	\item Complete sorting: $O(n \log n)$
	\item Intiial ordering does not affect efficency
	\end{itemize}
\end{itemize}
\end{frame}

%\begin{frame}\frametitle{Sorting - Code}
%Basic heap sort code
%\lstinputlisting[basicstyle=\tiny, firstline=5]{code/heap-sort.cpp}
%\end{frame}

%\begin{frame}\frametitle{Sorting - Code}
%Output
%\verbatiminput{code/heap-sort-output.txt}
%\end{frame}

\begin{frame}\frametitle{Sorting - Efficiency Table}
Efficiencies of sorting algorithms
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline Algorithm & Best & Average & Worst\\\hline
Selection & $O(n^2)$ & $O(n^2)$ & $O(n^2)$\\\hline
Bubble & $O(n)$ & $O(n^2)$ & $O(n^2)$\\\hline
Insertion & $O(n^2)$ & $O(n^2)$ & $O(n^2)$\\\hline
Quick & $O(n\log n)$ & $O(n\log n)$ & $O(n^2)$\\\hline
Radix & $O(nk)$ & $O(nk)$ & $O(nk)$\\\hline
Heap & $O(n\log n)$ & $O(n\log n)$ & $O(n\log n)$\\\hline
\end{tabular}
\end{center}
\end{frame}

