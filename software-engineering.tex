\section{Software Engineering}
\begin{frame}\frametitle{Software Engineering - Overview}
\begin{itemize}
\item Attributes of good software
	\begin{itemize}
	\item Works
	\item Can be easily modified
	\item Is reusable
	\item Is completed within time and budget requirements
	\end{itemize}
\item Software engineering: The proper application of the principles of design, production, and maintenance of software
	\begin{itemize}
	\item Technical challenges
	\item Project management
	\end{itemize}
\item Defects in code
	\begin{itemize}
	\item About 1 error is created for every 10 lines of code
	\item 75\% of a code's cost is in maintenance of that code
	\end{itemize}
\item Software process: The process by which software is developed and maintained
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Software Engineering - Parts of Software Development}
\begin{itemize}
\item Requirements: High-level description of the product
\item Specification: Detailed description containing functional requirements and constraints
\item Design: Architectural (high-level) and detailed (low-level) design of the product
\item Implementation: Converting the design into code
\item Testing/Verification: Finding and fixing errors and demonstrating that the product works correctly
\item Postdelivery/Maintenance: Correct errors found by users and enhancing functionality
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Software Engineering - Processes}
\begin{itemize}
\item Waterfall process: Each step of the process is an input for the next step
\item Agile process: Emphasizing individuals/interactions and working software over specific processes in order to enable quick changing and customer collaboration
\item Scrum: Work is designed to be done in short periods called ``sprints,'' with daily work being determined by the needs of the current sprint
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Software Engineering - Testing Overview}
\begin{itemize}
\item Testing: Trying to discover errors within a program
\item Debugging: Removing known errors from a program
\item Driver: A program specifically designed to test a part of code
\item Stub: Dummy code designed to simulate real-life use cases
\item Assertion: A statement that is either true or false
\item Precondition: An assertion that must be true in order for a postcondition to be returned
\item Postcondition: An assertion that is expected from a certain precondition
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Software Engineering - Testing Hierarchy and Types}
\begin{itemize}
\item Deskchecking: Informal checking by the developer
\item Unit testing: Formally testing individual parts of a program by themselves
\item Integration testing: Formally and systematically testing a part of a program within the larger code base
\item Acceptance testing: Testing the program with real data in its real environment
\item Regression testing: Testing a program following modifications
\item Black-box testing: Testing a program by its inputs and outputs
\item Clear-box testing: Testing a program utilizing knowledge of its structure
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Software Engineering - Verification VS Validation}
\begin{itemize}
\item Verification: The program works properly
\item Validation: The program satisfies the needs of the problem
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Software Engineering - Other Notes}
\begin{itemize}
\item When creating interfaces, checking can exist in either in the interface implementation, or within client code (Varies by occasion)
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Software Engineering - Metric-Based Testing}
\begin{itemize}
\item Metric-based testing: Using measurable factors to evaluate how through the testing has been performed
\item Code coverage: How much of the code has been tested
	\begin{itemize}
	\item Necessary, but not sufficient part of software testing
	\item Statement coverage: Percentage of code statements executed
	\item Branch coverage: Does the logical branching execute properly?
	\item Path coverage: How many possible paths can be taken in the code?
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Software Engineering - Tools}
\begin{itemize}
\item gcov: Evaluates code coverage
	\begin{itemize}
	\item Command: g++ -fprofile-arcs -ftest-coverage [object].o -o [executable name]\\
	$[$execute the program$]$\\
	gcov [source file]
	\end{itemize}
\item gdb: debugger
	\begin{itemize}
	\item Command: g++ [source file].cpp -g -o [executable name]\\
	gdb ./[executable]
	\end{itemize}
\item valgrind: bug checker
	\begin{itemize}
	\item Command: valgrind --leak-check=[summary/full] ./[executable]
	\end{itemize}
\end{itemize}
\end{frame}
